var State = Enum(
    "PENDING",
    "FULFILLED",
    "REJECTED"
)

class Promise
    construct(func=null)
        this._state = State.PENDING
        this._value = null
        this._handlers = []

        if func
            func(this.fulfill, this.reject)
        end
    end

    fun fulfill(value=null)
        if this._state != State.PENDING
            raise AlreadyResolvedException()
        end

        this._state = State.FULFILLED
        this._value = value

        for var subPromise, onFulfilled, _ in this._handlers
            this._invoke(subPromise, onFulfilled)
        end
    end

    fun reject(exception)
        typeAssert(exception, Exception, "exception")

        if this._state != State.PENDING
            raise AlreadyResolvedException()
        end

        this._state = State.REJECTED
        this._value = exception
       
        for var subPromise, _, onRejected in this._handlers
            this._invoke(subPromise, onRejected)
        end
    end

    fun then(onFulfilled=null, onRejected=null)
        var promise = Promise()
        if this._state == State.FULFILLED
            this._invoke(promise, onFulfilled)
        elif this._state == State.REJECTED
            this._invoke(promise, onRejected)
        else
            this._handlers.add((promise, onFulfilled, onRejected))
        end
        return promise
    end

    fun catch(onRejected)
        return this.then(null, onRejected)
    end

    fun _invoke(promise, callback)
        if callback is Function
            try
                var res = callback(this._value)
                if res is Promise
                    res.then(promise.fulfill, promise.reject)
                else
                    promise.fulfill(res)
                end
            except Exception e
                promise.reject(e)
            end
        elif this._state == State.FULFILLED
            promise.fulfill(this._value)
        elif this._state == State.REJECTED
            promise.reject(this._value)
        end
    end
end

fun resolved(val)
    if val is Promise
        return val
    end
    var p = Promise()
    p.fulfill(val)
    return p
end

fun rejected(exc)
    if exc is Promise
        return exc
    end
    var p = Promise()
    p.reject(exc)
    return p
end

class AlreadyResolvedException is Exception
    fun new(cause=null)
        super("Promise has already been fulfilled or rejected", cause)
    end
end
